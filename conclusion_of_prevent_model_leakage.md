## 最終的に採用するモデル流出対策

### 1. モデルデータの暗号化

**対策内容:**

- **モデルの暗号化:**
  - モデルデータをAES-256などの強力な暗号化アルゴリズムで暗号化し、サーバーに保存します。
- **チャンク単位での復号化:**
  - アプリ側でモデルデータをダウンロード後、ストリームを使用してチャンクごとに復号化します。
  - 復号化したデータをファイルとして保存し、llama.cppで読み込めるようにします。

**メリット:**

- 暗号化されたモデルデータは、鍵がなければ利用できないため、流出しても安全性が保たれます。
- チャンク単位での復号化により、大容量のモデルでもメモリ効率よく扱えます。
- 実装が比較的容易であり、既存の暗号化ライブラリやストリーム処理を活用できます。

**デメリット:**

- 復号化処理により、モデル読み込み時のパフォーマンスが若干低下する可能性があります。
- デバイスのI/O性能によっては、読み込み速度がボトルネックになる場合があります。

---

### 2. 暗号鍵の安全な管理（Android Keystoreの利用）

**対策内容:**

- **Android Keystoreの利用:**
  - 暗号化・復号化に使用する鍵をAndroid Keystoreシステムで安全に管理します。
  - 鍵はデバイス内に安全に保存され、アプリ外からのアクセスや抽出が困難になります。

**メリット:**

- 鍵の安全性が高まり、鍵の漏洩リスクが低減します。
- システムレベルでの保護により、セキュリティが強化されます。

**デメリット:**

- デバイスがRoot化されている場合、鍵が抽出されるリスクがあります。
- 一部の古いデバイスやOSバージョンでは、Keystoreの機能が制限される可能性があります。

---

### 3. 認証と安全な通信の実装（証明書ピンニング）

**対策内容:**

- **安全な通信の確立:**
  - アプリとサーバー間の通信において、HTTPSを使用し、証明書ピンニングを実装します。
  - 中間者攻撃を防止し、通信データの盗聴や改ざんを防ぎます。

**メリット:**

- 通信経路でのセキュリティが強化され、データの安全な送受信が可能になります。
- 不正なデバイスやユーザーからのアクセスを制限できます。

**デメリット:**

- 証明書の管理が必要であり、証明書の更新時にはアプリのアップデートが必要になる場合があります。
- 実装が複雑であり、専門的な知識が求められます。

---

## 採用しない対策

### 部分的・ストリーミング復号化の実装

**理由:**

- **高い実装コスト:**
  - llama.cppの大幅な改良が必要で、開発工数と技術的難易度が大幅に増加します。
- **労力に見合わない:**
  - チャンク単位での復号化で十分な効果が得られるため、追加の労力に対するメリットが限定的です。

---

## 実装時のポイント

- **モデルデータの暗号化:**
  - サーバー側でモデルデータを暗号化し、アプリ側でチャンク単位で復号化します。
  - 復号化したデータはファイルとして保存し、llama.cppで読み込みます。
- **暗号鍵の管理:**
  - Android Keystoreを使用して暗号鍵を安全に管理し、鍵の漏洩を防ぎます。
- **通信のセキュリティ:**
  - HTTPSと証明書ピンニングを実装し、アプリとサーバー間の通信を保護します。

---

## まとめ

- **採用する対策:**
  - モデルデータの暗号化（チャンク単位での復号化を含む）
  - 暗号鍵の安全な管理（Android Keystoreの利用）
  - 認証と安全な通信の実装（証明書ピンニング）
- **採用しない対策:**
  - 部分的・ストリーミング復号化の実装
- **理由:**
  - 労力と効果のバランスを考慮し、実装負担が少なく効果の高い対策を優先しました。
  - 開発工数が大幅に増加する対策は、現時点では採用しません。

---
